<!DOCTYPE html>
<html>
<head>

<meta http-equiv="content-type" content="text/html;charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<meta name="author" content="billbyte"/>
<title>webgpu app</title>

<style>



*{
margin: 0;
padding: 0;
box-sizing:border-box;
/* border: 0.1px solid red; */
}



html{
font-size: 10px;
}

a{
text-decoration: none;
}

li{
list-style:none;
}




body{
/* display:grid; */
/* grid-template-columns: repeat(auto-fit, minmax(20rem, 1fr)); */
/* grid-template-rows: repeat(2, 1fr); */
/* place-items:center; */
/* gap: 1rem; */
background: #3e3e3e;

}

canvas{
margin: auto;
background:#FF986E;
}


.error_box{
margin: 2rem 0;
background:transparent;
overflow:hidden auto;
}

.title{
color:#222A3B;
font-size: 3rem;
display:block;
text-align: center;
text-transform: capitalize;
background: linear-gradient(45deg,red, blue);
text-decoration: underline;
}

.error_box  p{
margin:0.2rem 1rem;
padding: 1rem ;

background: #0009;
color: #FF374E;
border-radius: 1rem;
}


.hidden{
display: none;
}

</style>

</head>
<body>

<main>

<canvas id="canvas"></canvas>

<div class="error_box">
<span class="title">error and warning</span>
<pre></pre>
</div>

</main>

<div class="hidden">
<img src="/storage/emulated/0/Download/images (7).jpeg" id="img1" />
<img src="/storage/emulated/0/Download/Zelda2.png" id="img2" />
<img src="/storage/emulated/0/Download/images (9).jpeg" id="img3" />
<img src="/storage/emulated/0/Download/images (10).jpeg" id="img4" />
</div>

<script>



const {PI, cos, sin, tan} = Math;



const showError=(msg)=>{
console.log(msg)
const errorContainer=document.querySelector(".error_box > pre")
if(!errorContainer)
	return -1;
errorContainer.innerHTML+=`<p>${msg}</p>`;
}



class Rand{

static Float(min=0, max=1){
return Math.random() (max - min) + min;
}

static Int(min=1, max=2){
return Math.floor(Rand.Float(min, max));
}

static Choice(...args){
return args[Rand.Int(0, args.length)];
}


}







const INIT=async ()=>{

  if (!navigator.gpu) {
    throw Error("WebGPU not supported.");
  }

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    throw Error("Couldn't request WebGPU adapter.");
  }

  const device = await adapter.requestDevice();

  //...


const shaders = `
struct VertexOut {
  @builtin(position) position : vec4f,
  @location(0) color : vec4f
}

@vertex
fn vertex_main(@location(0) position: vec4f,
               @location(1) color: vec4f) -> VertexOut
{
  var output : VertexOut;
  output.position = position;
  output.color = color;
  return output;
}

@fragment
fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
{
  return fragData.color;
}
`;


const shaderModule = device.createShaderModule({
  code: shaders,
});



const canvas = document.querySelector("canvas");
const context = canvas.getContext("webgpu");

context.configure({
  device: device,
  format: navigator.gpu.getPreferredCanvasFormat(),
  alphaMode: "premultiplied",
});


const vertices = new Float32Array([
  0.0, 0.6, 0, 1, 1, 0, 0, 1, -0.5, -0.6, 0, 1, 0, 1, 0, 1, 0.5, -0.6, 0, 1, 0,
  0, 1, 1,
]);


const vertexBuffer = device.createBuffer({
  size: vertices.byteLength, // make it big enough to store vertices in
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
});


device.queue.writeBuffer(vertexBuffer, 0, vertices, 0, vertices.length);

const vertexBuffers = [
  {
    attributes: [
      {
        shaderLocation: 0, // position
        offset: 0,
        format: "float32x4",
      },
      {
        shaderLocation: 1, // color
        offset: 16,
        format: "float32x4",
      },
    ],
    arrayStride: 32,
    stepMode: "vertex",
  },
];


const pipelineDescriptor = {
  vertex: {
    module: shaderModule,
    entryPoint: "vertex_main",
    buffers: vertexBuffers,
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fragment_main",
    targets: [
      {
        format: navigator.gpu.getPreferredCanvasFormat(),
      },
    ],
  },
  primitive: {
    topology: "triangle-list",
  },
  layout: "auto",
};

const renderPipeline = device.createRenderPipeline(pipelineDescriptor);

const commandEncoder = device.createCommandEncoder();



const clearColor = { r: 0.0, g: 0.5, b: 1.0, a: 1.0 };

const renderPassDescriptor = {
  colorAttachments: [
    {
      clearValue: clearColor,
      loadOp: "clear",
      storeOp: "store",
      view: context.getCurrentTexture().createView(),
    },
  ],
};

const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);



passEncoder.setPipeline(renderPipeline);
passEncoder.setVertexBuffer(0, vertexBuffer);
passEncoder.draw(3);



passEncoder.end();

device.queue.submit([commandEncoder.finish()]);



}



window.addEventListener("load", ()=>{

try{


INIT();


showError("js is awesome".toUpperCase());


}catch(e){
showError(e);
}

});



</script>

</body>
</html>